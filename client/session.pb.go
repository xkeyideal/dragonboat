// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: session.proto
/*
	Package client implements the client Session struct for identifying proposal
	clients and their progress. Together with the LRU based session store on the
	server side, client Session helps to implement the at-most-once semantic. It
	ensures that when retrying a prviously timed out proposal, the retried
	proposal will not be applied twice if the previous proposal attempt actually
	succeed. See section 6.3 of Diego Ongaro's PhD thesis for more details.
*/
package client

import (
	"fmt"
	"io"
	"math"

	"github.com/lni/goutils/random"
)

const (
	// NotSessionManagedClientID is a special client id used to indicate
	// that the entry is not managed by a client session. This is used when
	// the entry is not generated by the user, e.g. the blank entry proposed
	// after becoming the leader.
	NotSessionManagedClientID uint64 = 0
	// NoOPSeriesID is a special series ID used to indicate that the client
	// session is a NOOP client session.
	NoOPSeriesID uint64 = 0
	// SeriesIDForRegister is the special series id used for registering
	// a new client session.
	SeriesIDForRegister uint64 = math.MaxUint64 - 1
	// SeriesIDForUnregister is the special series id used for unregistering
	// client session.
	SeriesIDForUnregister uint64 = math.MaxUint64
	// SeriesIDFirstProposal is the first series id to be used for making
	// proposals.
	SeriesIDFirstProposal uint64 = 1
)

var (
	ErrInvalidLengthSession = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSession   = fmt.Errorf("proto: integer overflow")
)

// Session is the struct used to keep tracking the progress of a client.
type Session struct {
	ShardID     uint64
	ClientID    uint64
	SeriesID    uint64
	RespondedTo uint64
}

func (*Session) ProtoMessage() {}

func (m *Session) Reset() { *m = Session{} }
func (m *Session) String() string {
	return fmt.Sprintf("%d:%d:%d:%d", m.ShardID, m.ClientID, m.SeriesID, m.RespondedTo)
}

// NewSession returns a new client session not registered yet. This function
// is not expected to be directly invoked by application.
func NewSession(shardID uint64, rng random.Source) *Session {
	for {
		cid := rng.Uint64()
		if cid != NotSessionManagedClientID {
			return &Session{
				ShardID:  shardID,
				ClientID: cid,
				SeriesID: NoOPSeriesID + 1,
			}
		}
	}
}

// NewNoOPSession creates a new NoOP client session ready to be used for
// making proposals. This function is not expected to be directly invoked by
// application.
func NewNoOPSession(shardID uint64, rng random.Source) *Session {
	for {
		cid := rng.Uint64()
		if cid != NotSessionManagedClientID {
			return &Session{
				ShardID:  shardID,
				ClientID: cid,
				SeriesID: NoOPSeriesID,
			}
		}
	}
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSession(dAtA, i, uint64(m.ShardID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSession(dAtA, i, uint64(m.ClientID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSession(dAtA, i, uint64(m.SeriesID))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSession(dAtA, i, uint64(m.RespondedTo))
	return i, nil
}

func encodeVarintSession(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSession(uint64(m.ShardID))
	n += 1 + sovSession(uint64(m.ClientID))
	n += 1 + sovSession(uint64(m.SeriesID))
	n += 1 + sovSession(uint64(m.RespondedTo))
	return n
}

func sovSession(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}

func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesID", wireType)
			}
			m.SeriesID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespondedTo", wireType)
			}
			m.RespondedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespondedTo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func skipSession(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSession
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSession
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSession
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSession(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

// IsNoOPSession returns a boolean flag indicating whether the session instance
// is a NoOP session.
func (m *Session) IsNoOPSession() bool {
	return m.SeriesID == NoOPSeriesID
}

// ShardIDMustMatch asserts that the input shard id matches the shard id
// of the client session.
func (m *Session) ShardIDMustMatch(shardID uint64) {
	if m.ShardID != shardID {
		panic("shard id do not match")
	}
}

// PrepareForRegister sets the series id to the special series id for
// registering client session.
func (m *Session) PrepareForRegister() {
	m.assertRegularSession()
	m.SeriesID = SeriesIDForRegister
}

// PrepareForUnregister sets the series id to the special series id for
// unregistering client session.
func (m *Session) PrepareForUnregister() {
	m.assertRegularSession()
	m.SeriesID = SeriesIDForUnregister
}

// PrepareForPropose sets the series id to the first series id that can be used
// for making proposals.
func (m *Session) PrepareForPropose() {
	m.assertRegularSession()
	m.SeriesID = SeriesIDFirstProposal
}

// ProposalCompleted increases the series id and the RespondedTo value.
// ProposalCompleted is expected to be called by the application every time
// when a proposal is completed or aborted by the application.
func (m *Session) ProposalCompleted() {
	m.assertRegularSession()
	if m.SeriesID == m.RespondedTo+1 {
		m.RespondedTo = m.SeriesID
		m.SeriesID++
	} else {
		panic("invalid responded to/series id values")
	}
}

func (m *Session) assertRegularSession() {
	if m.ClientID == NotSessionManagedClientID ||
		m.SeriesID == NoOPSeriesID {
		panic("not a regular session")
	}
}

// ValidForProposal checks whether the client session object is valid for
// making proposals.
func (m *Session) ValidForProposal(shardID uint64) bool {
	if m.SeriesID == NoOPSeriesID && m.ClientID == NotSessionManagedClientID {
		return false
	}
	if m.ShardID != shardID {
		return false
	}
	if m.ClientID == NotSessionManagedClientID {
		return false
	}
	if m.SeriesID == SeriesIDForRegister ||
		m.SeriesID == SeriesIDForUnregister {
		return false
	}
	if m.RespondedTo > m.SeriesID {
		panic("m.RespondedTo > m.SeriesID")
	}
	return true
}

// ValidForSessionOp checks whether the client session is valid for
// making client session related proposals, e.g. registering or unregistering
// a client session.
func (m *Session) ValidForSessionOp(shardID uint64) bool {
	if m.ShardID != shardID {
		return false
	}
	if m.ClientID == NotSessionManagedClientID ||
		m.SeriesID == NoOPSeriesID {
		return false
	}
	if m.SeriesID == SeriesIDForRegister ||
		m.SeriesID == SeriesIDForUnregister {
		return true
	}
	return false
}
